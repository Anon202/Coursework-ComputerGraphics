#include <iostream>
#include <glm\glm.hpp>
#include <glm\gtc\quaternion.hpp>
#include <glm\gtc\constants.hpp>
#include <glm\gtc\matrix_transform.hpp>
#include <glm\gtx\euler_angles.hpp>
#include <glm\gtx\projection.hpp>

using namespace std;
using namespace glm;

int main()
{ /*
	// v2
	vec2 u1(1.0f, 0.0f);
	//vec2 u2(0.0f, 1.0f);

	//v3
	vec3 v1(0.0f, 0.0f, 1.0f);
	vec3 v2(0.0f, 1.0f, 0.0f);

	//v4
	vec4 w1(0.0f, 0.0f, 0.0f, 1.0f);
	vec4 w2(0.0f, 0.0f, 1.0f, 0.0f);

	// 2d to 3d
	vec3 v3(u1, 0.0f);

	// 3d to 2d
	vec2 u3(vec3(1.0f, 0.0f, 0.0f)); // z dropped

	// 2d to 4d
	vec4 w3(vec2(0.0f, 0.0f), 0.0f, 1.0f);

	// 3d to 4d
	vec4 w4(vec3(0.0f, 1.0f, 0.0f), 0.0f);

	// 4d to 3d
	vec3 u4(vec4(1.0f, 0.0f, 0.0f, 0.0f));

	// 4d to 2d
	vec2 u2(vec4(1.0f, 0.0f, 0.0f, 0.0f));


	float x = u1.x;   // gets and sets components
	u1.y = 10.0f;


	vec3 a = v1 + v2;  // additon/subtraction

	// scaling 
	vec3 b(1.0f, 0.0f, 0.0f);
	vec3 c = 5.0f * b;
	vec3 d1 = b / 5.0f;

	// length
	float l = length(v1);


	// norm
	vec3 n = normalize(b);


	// dot product
	float d = dot(a, b);

	// projection
	vec3 p = proj(v1, v2);

	vec3 c2 = cross(v1, v2);

	
	// MATRIX 

	// Identity matrix
	mat4 m(1.0f);

	// can convert between matrix types as with vectors 
	mat3 n1(m);

	// can add and subtract and scale as before
	mat4 o = m + mat4(1.0f);

	mat4 p1 = 5.0f * o; */



}